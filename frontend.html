<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>SSE Upload + Query Test</title>
  <style>
    body { font-family: Inter, Arial, sans-serif; padding:18px; max-width: 900px; }
    .row { margin: 10px 0; }
    .log { border:1px solid #eee; padding:8px; height:180px; overflow:auto; background:#fafafa; white-space:pre-wrap; }
    .toast { padding:8px 12px; border-radius:8px; color:#fff; margin-bottom:8px; }
    .toast.warn { background:#d97706; }
    .toast.info { background:#2b6cb0; }
    .controls { display:flex; gap:10px; align-items:center; }
    .small { font-size:0.9rem; color:#666; }
    #answer { white-space:pre-wrap; border:1px solid #ddd; padding:10px; min-height:120px; background:#fff; }
  </style>
</head>
<body>
  <h2>Upload (SSE for retry-only) + Query Test</h2>

  <div class="row controls">
    <input type="file" id="fileInput" accept="application/pdf" />
    <button id="startBtn">Open SSE & Upload</button>
    <span class="small" id="status">idle</span>
  </div>

  <div class="row">
    Upload progress: <progress id="progress" max="100" value="0" style="width:420px; margin-left:10px;"></progress>
  </div>

  <div class="row">
    <div><strong>Server SSE Log (retry messages only)</strong></div>
    <div id="log" class="log"></div>
  </div>

  <hr />

  <div class="row">
    <input type="text" id="question" placeholder="Ask something (e.g. 'what is the renewal process for the policy?')" style="width:70%" />
    <button id="askBtn">Ask</button>
    <input type="text" id="fileIdInput" placeholder="file_id (if unknown, upload first)" style="width:25%" />
  </div>

  <div class="row">
    <div><strong>Answer (streaming)</strong></div>
    <div id="answer"></div>
  </div>

  <div id="toasts"></div>

<script>
function now() { return new Date().toLocaleTimeString(); }
function addLog(txt) {
  const el = document.getElementById('log');
  const d = document.createElement('div');
  d.textContent = `${now()} â€” ${txt}`;
  el.appendChild(d);
  el.scrollTop = el.scrollHeight;
}
function showToast(text) {
  const t = document.createElement('div');
  t.className = 'toast warn';
  t.textContent = text;
  const root = document.getElementById('toasts');
  root.appendChild(t);
  setTimeout(()=> t.remove(), 7000);
}

// v4-like uuid
function randomId(){
  return ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g, c =>
    (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)
  );
}

// elements
const startBtn = document.getElementById('startBtn');
const fileInput = document.getElementById('fileInput');
const progress = document.getElementById('progress');
const status = document.getElementById('status');
const askBtn = document.getElementById('askBtn');
const fileIdInput = document.getElementById('fileIdInput');
const answerEl = document.getElementById('answer');

let currentEventSource = null;
let currentFileId = null;

startBtn.onclick = async () => {
  const file = fileInput.files[0];
  if (!file) return alert('Choose a PDF first');

  currentFileId = randomId();
  fileIdInput.value = currentFileId;
  status.textContent = `file_id=${currentFileId}`;
  addLog(`Client created file_id=${currentFileId}`);

  // open SSE first
  const sseUrl = `http://localhost:8000/events/${currentFileId}`;
  addLog(`Opening SSE -> ${sseUrl}`);
  const es = new EventSource(sseUrl);
  currentEventSource = es;

  es.onopen = () => { addLog('SSE connected'); }
  es.onmessage = (e) => {
    const msg = e.data;
    // per your instruction: SSE will only send retry messages (and __DONE__ possibly)
    addLog(`[SSE] ${msg}`);
    if (msg && msg.toLowerCase().includes('retrying')) {
      showToast(msg);
    }
    if (msg === '__DONE__') {
      addLog('SSE: ingestion signaled done');
      // closing SSE is safe
      try { es.close(); addLog('SSE closed'); } catch(e){}
    }
  };
  es.onerror = (err) => {
    addLog('SSE disconnected or error');
  };

  // small wait to ensure server created listener
  await new Promise(r=>setTimeout(r, 200));

  // upload via XMLHttpRequest to see progress
  const form = new FormData();
  form.append('file', file, file.name);
  form.append('file_id', currentFileId);

  const xhr = new XMLHttpRequest();
  xhr.open('POST', 'http://localhost:8000/upload', true);
  xhr.upload.onprogress = (evt) => {
    if (evt.lengthComputable) {
      const pct = Math.round((evt.loaded / evt.total) * 100);
      progress.value = pct;
      status.textContent = `Uploading ${pct}% (file_id=${currentFileId})`;
    }
  };
  xhr.onload = () => {
    if (xhr.status >= 200 && xhr.status < 300) {
      addLog('[HTTP] Upload accepted - ingestion started by server');
      status.textContent = 'ingestion_started';
    } else {
      addLog(`[HTTP] Upload failed: ${xhr.status} ${xhr.statusText}`);
      status.textContent = 'upload_failed';
    }
  };
  xhr.onerror = () => {
    addLog('[HTTP] Upload error');
    status.textContent = 'upload_error';
  };
  xhr.send(form);
  addLog('[HTTP] upload started');
};

askBtn.onclick = async () => {
  const q = document.getElementById('question').value.trim();
  const file_id = document.getElementById('fileIdInput').value.trim();
  if (!q) return alert('Type a question');
  if (!file_id) return alert('Enter file_id (upload first)');

  answerEl.textContent = '';
  addLog(`Querying file_id=${file_id} q="${q}"`);
  showToast('Query started');

  // POST form and stream response
  const form = new FormData();
  form.append('file_id', file_id);
  form.append('question', q);
  form.append('k', 5);

  try {
    const resp = await fetch('http://localhost:8000/query', { method: 'POST', body: form });
    if (!resp.ok) {
      const text = await resp.text();
      addLog(`[HTTP] query failed: ${resp.status} ${text}`);
      return;
    }
    // stream reader
    const reader = resp.body.getReader();
    const decoder = new TextDecoder();
    while (true) {
      const { done, value } = await reader.read();
      if (done) break;
      const chunk = decoder.decode(value, { stream: true });
      answerEl.textContent += chunk;
      answerEl.scrollTop = answerEl.scrollHeight;
    }
    addLog('Query stream finished');
  } catch (e) {
    addLog('Query error: ' + e.toString());
  }
};
</script>
</body>
</html>
